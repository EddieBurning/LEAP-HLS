LEAP-HLS
===========

Integrate HLS designs into the LEAP framework
-----------

This repository contains code in support of the tutorial "The LEAP Run-time System â€“ Rapid System Integration of Your HLS Kernels", held at the International Conference on Field-programmable Logic and Applications 2015 (http://www.fpl2015.org/?page=tutorials#t4).

Current HLS systems typically provide very simple FPGA-side memory and I/O sub-systems. HLS users commonly face the problem that the application data do not fit in the FPGA on-chip memory and connecting the HLS kernel with an external memory is an extensive, time-consuming task. The LEAP operating environment provides composable components and services for connecting FPGA kernels to external memory sub-systems through high-performance interfaces, and for building hybrid implementations combining FPGAs and software. These code examples show how to integrate Vivado HLS designs into the LEAP environment and describe the interfaces through which the HLS-generated kernels are supported by cache-based, application-specific memory hierarchies.

We provide two code examples:
  * Merger: A light-weight example using only private memory regions
  * The filtering algorithm: A more complicated implementation of K-means clustering using private and shared memory regions as well as LEAP's lock synchronization service

Instructions for building the applications are in the README file in each folder. To build and run the examples, the following tools/ software packages must be installed:

  * The LEAP Run-time System as described [here](https://github.com/LEAP-FPGA/leap-documentation/wiki). The code examples have been tested with LEAP release version 15.02 running on a Ubuntu 12.04 "Precise" machine.
  * The Bluespec compiler (http://www.bluespec.com) for compiling LEAP programs. The code examples have been tested with Bluespec 2014-07-A.
  * Xilinx Vivado for RTL implementation. LEAP requires a Vivado version >= 2014.4. The code examples have been tested with Vivado 2014.4.
  * Optionally, Synopsys Synplify can be used for netlist synthesis instead of Vivado (Vivado is still required for placement and routing). The code examples have been tested with Synplify Premier 2014.03.1.
  * Xilinx Vivado HLS for RTL code generation. Unfortunately, there seems to be a minor problem with the bus interfaces generated by Vivado HLS 2014.4 that results in undefined memory accesses in our code examples. For this reason, we recommend to use Vivado HLS 2014.1 for high-level synthesis. The problem is currently being investigated in order to avoid the need for two different Vivado versions.
  * Icarus Verilog (iverilog, http://iverilog.icarus.com/) for RTL simulation if required. The code examples have been tested with iverilog 0.9.7.
  * The code examples are built for and have been tested on a Xilinx VC707 FPGA board (Virtex 7). If Xilinx board access is required, the BlueNoc drivers for PCIe access, and the Digilent JTAG Chipset and Xilinx Impact for programming the FPGA must be installed. Instructions and troubleshooting are [here](https://github.com/LEAP-FPGA/leap-documentation/wiki/ML605-and-VC707).

This repository is currently under construction.

(c) Felix Winterstein, Imperial College London. The source code is distributed under a 3-clause BSD license (see LICENSE.txt). 
